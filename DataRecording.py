#FOR REFERENCE: https://www.youtube.com/watch?v=iaQirRf2V7E&feature=youtu.be

import tkinter as tk
from PIL import Image, ImageTk
import random
import glob

#Imported from DataRecording
import time
import datetime as dt
import os


# Directory where the photos for the slideshow are located
# Photos are shown in alphabetical order
picture_folder = r'A:\Files\2021\CI Information\Pictures\*'

# Define number of iterations to run
n = 2

# Seconds to wait
secs = 1

## ADD second button to exit out of tests when in loop
## use while loop


# Session Timestamp Data File
data_file = 'DataTime_' + dt.datetime.now().strftime("%Y-%m-%d_%H-%M-%S") + '.txt'
data_file = 'DataTime.txt'


for x in range(n):
    
    # Check if starting data collection process
    if x == 0:
        # Check if file exists
        if os.path.exists(data_file) == True:    
            
            # Check if file is empty
            if os.stat(data_file).st_size == 0:
                
                # Adds file header if file is empty
                with open(data_file, 'a') as file:
                    file.write('=== Autogenerated Timestamps ==='+ \
                    '\nTime\t\t\t\t\t\t| Timestamp\t\t\t| Event\n')
        
        else:
            # Creates file and adds file header
                with open(data_file, 'a') as file:
                    file.write('=== Autogenerated Timestamps ==='+ \
                    '\n\t\t\tTime\t\t\t|\tTimestamp\t\t|\tEvent\n')
    


class gui:
    #defines the main window, init takes two "_" per side, not one oops


    def __init__(self, mainwin):


        self.pic_list = []

        #THE DIRECTORY WOULD HAVE TO BE CHANGED
        #THE DIRECTORY WOULD HAVE TO BE CHANGED
        #THE DIRECTORY WOULD HAVE TO BE CHANGED
        for name in glob.glob(picture_folder):
            val = name
            self.pic_list.append(val)


        #A counter to find the data appended by pic function, AKA: where in the array we are
        self.counter = 0

        self.mainwin = mainwin
        self.mainwin.title('Tkinter Picture Frame')
        #zoomed makes it your full screen
        self.mainwin.state("zoomed")

        self.mainwin.configure(bg = 'white')
        
        #the frame is contained in the main window
        self.frame = tk.Frame(mainwin)
        self.frame.configure(bg = 'white')
        
        #The self.img is the image acting as a lable in tk
        self.img = tk.Label(self.frame)
        self.img.pack()
        
        #Defines the relative size of the frame inside the window
        self.frame.place(relheight = 0.85, relwidth = 0.9, relx = 0.05, rely = 0.05)

        #runs the background color changer (if you want)
        #self.color()
        self.pic()




#pic function is for finding/viewing the pictures using "glob"
    def pic(self):
        
        #print(self.counter) #was a test line

        #Loading the image in proper size
        self.file = self.pic_list[self.counter]
        self.load = Image.open(self.file)
        self.pic_width = self.load.size[0]
        self.pic_height = self.load.size[1]
        self.real_aspect = self.pic_width/self.pic_height
        self.cal_width = int(self.real_aspect * 800)
        self.load2 = self.load.resize((self.cal_width, 800))
        self.render = ImageTk.PhotoImage(self.load2)
        self.img.config(image = self.render)
        self.img.image = self.render
        #End of image load

        #We can use the self.pic_list[self.counter] to describe the events
        self.string = f'Path: {self.pic_list[self.counter]}' #F string to contain the information to be put into txt files
        print(self.string)


        #ADDED 1/29/2021 - DOES THIS WORK TO WRITE INTO THE FILE
        with open(data_file, 'a') as file:
         file.write('%s\t| %s\t| %s\n' %(dt.datetime.now(), \
            dt.datetime.now().timestamp(), self.string))


        #iteration of self.counter to cycle through which point in the array 
        if self.counter == len(self.pic_list) - 1:
            self.counter = 0
        else:
            self.counter = self.counter + 1


        #Root.after was the old way to repeat this function 
        root.after(2000, self.pic)

root = tk.Tk()
myprog = gui(root)
root.mainloop()
